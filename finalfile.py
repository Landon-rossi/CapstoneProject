# -*- coding: utf-8 -*-
"""FinalFile.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IzzJd8NFgTpMYL-Mr6GDxXgCHjQ3_Azr

Dataset Imports and Packages
"""

import pandas as pd
from keras.models import Sequential
from keras.layers import Dense, Dropout, LSTM, GRU, Flatten, Conv1D, Conv2D
from keras.layers import MaxPooling1D, MaxPooling2D
from sklearn.model_selection import train_test_split
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
import ipywidgets as widgets
from IPython.display import display, clear_output
import warnings

SolarWindData = pd.read_csv('SO_ML_2022Jan_to_2023Apr.csv', skiprows=[0])
pwr_tran_train_data = read.csv("pwrtrantrainset.csv")
min_max_train_data = read.csv("minmaxtrainset.csv")

"""Preprocessing"""

df2 = SolarWindData.isna()
Ratio = SolarWindData['O7_O6_ratio']
negativerows = []

index = 0
for i in Ratio:
  if i <= 0:
    negativerows.append(index)
  index += 1

for i in negativerows:
  SolarWindData.drop(i, inplace=True)

SolarWindData.reset_index(drop=True, inplace=True)

infinite_values = SolarWindData.isin([np.inf])
Velocity = SolarWindData['velocity']

infiniterows = []
index = 0
for i in Velocity:
  if i == np.inf:
    infiniterows.append(index)
  index += 1

for i in infiniterows:
  SolarWindData.drop(i, inplace=True)

SolarWindData.reset_index(drop=True, inplace=True)
SolarWindData.drop(['fractional_year'], axis=1, inplace=True)
minmax = MinMaxScaler()
mmx = minmax.fit_transform(SolarWindData)
mmx = pd.DataFrame(mmx, columns=SolarWindData.columns)
power = PowerTransformer()
pwt = power.fit_transform(SolarWindData)
pwt = pd.DataFrame(pwt, columns=SolarWindData.columns)

"""Train test Split"""

min_max_x_train, min_max_x_test, min_max_y_train, min_max_y_test = train_test_split(min_max_train_data.drop('Label', axis=1), min_max_train_data['Label'], test_size=0.2, random_state=42)
pwr_tran_x_train, pwr_tran_x_test, pwr_tran_y_train, pwr_tran_y_test = train_test_split(pwr_tran_train_data.drop('Label', axis=1), pwr_tran_train_data['Label'], test_size=0.2, random_state=42)

"""MinMaxModel"""

def MinMaxModel(n_features, loss_function, n_classes):
    model = Sequential()
    model.add(GRU(256, activation='tanh', return_sequences=True, input_shape=n_features))
    model.add(Dropout(0.2))
    model.add(Dense(64, activation='tanh'))
    model.add(Flatten())
    model.add(Dense(n_classes, activation='softmax'))

    model.compile(loss=loss_function, optimizer='adam', metrics=['accuracy'])
    return model

min_max_model = MinMaxModel((min_max_x_train.shape[1],1), loss_function='sparse_categorical_crossentropy', n_classes=2)
history = min_max_model.fit(min_max_x_train, min_max_y_train, epochs=25, batch_size=32, validation_split=0.2)

"""Power Transformer Model"""

def PwrTranModel(n_features, loss_function, n_classes):
  model = Sequential()
  model.add(Dense(256, activation='relu', input_shape=n_features))
  model.add(Conv1D(128, 3, activation='relu'))
  model.add(Dropout(0.2))
  model.add(Dense(64, activation='relu'))
  model.add(Flatten())

  model.add(Dense(n_classes, activation='softmax'))

  model.compile(loss=loss_function, optimizer='adam', metrics=['accuracy'])
  return model

pt_model = PwrTranModel((pwr_tran_x_train.shape[1],1), loss_function='sparse_categorical_crossentropy', n_classes=3)
history = pt_model.fit(pwr_tran_x_train, pwr_tran_y_train, epochs=25, batch_size=32, validation_split=0.2)

"""Widget framework"""

import ipywidgets as widgets
from IPython.display import display, clear_output

User_Input = []
User_Mode = []

#parameter names that line up with each slider
parameter_names = ['07_06_ratio', 'C6_C4_ratio', 'C6_C5_ratio', 'Fe_O_ratio', 'O_ave_charge', 'velocity', 'density']
out = widgets.Output()

button1 = widgets.Button(description="Simple Wind Classification", button_style='primary')
button2 = widgets.Button(description="Complex Wind Classification", button_style='success')

display_area = widgets.VBox()

def show_sliders(option_chosen):
      clear_output(wait=True)
      print(f"You selected {option_chosen}. Customize your parameters:")
      #These are the modifiable parameters, mean value is the value paramter on each slider, same with min and max
      slider1 = widgets.FloatSlider(description=f"{parameter_names[0]}", min=0.012432, max=2.588494, step=0.000001, value=0.192559, readout_format = '.6f')
      slider2 = widgets.FloatSlider(description=f"{parameter_names[1]}", min=0.149342, max=132.440323, step=0.000001, value=5.257230, readout_format = '.6f')
      slider3 = widgets.FloatSlider(description=f"{parameter_names[2]}", min=0.058647, max=12.090635, step=0.000001, value=0.594644, readout_format = '.6f')
      slider4 = widgets.FloatSlider(description=f"{parameter_names[3]}", min=0, max=8.980139, step=0.000001, value=0.167487, readout_format = '.6f')
      slider5 = widgets.FloatSlider(description=f"{parameter_names[4]}", min=5.907891, max=7.608771, step=0.000001, value=6.183532, readout_format = '.6f')
      slider6 = widgets.FloatSlider(description=f"{parameter_names[5]}", min=231.3, max=803.652, step=0.000001, value=427.132751, readout_format = '.6f')
      slider7 = widgets.FloatSlider(description=f"{parameter_names[6]}", min=0.959811, max=348.752, step=0.000001, value=24.397044, readout_format = '.6f')
      run_button = widgets.Button(description="Run", button_style='info')
      sliders = [slider1, slider2, slider3, slider4, slider5, slider6, slider7]

      def on_run_clicked(b):
          clear_output(wait=True)
          print(f"Settings from {option_chosen}:")
          for i, slider in enumerate(sliders):
              print(f"{parameter_names[i]}: {slider.value}")

              User_Input.append(slider.value)
          print(User_Input)

      run_button.on_click(on_run_clicked)
      display(widgets.VBox(sliders + [run_button]))

def on_button1_clicked(b):
    show_sliders("Simple Wind Classification")
    User_Mode.append('Min_max')
    print(User_Mode)

def on_button2_clicked(b):
    show_sliders("Complex Wind Classification")
    User_Mode.append('Pwr_Tran')
    print(User_Mode)

button1.on_click(on_button1_clicked)
button2.on_click(on_button2_clicked)
display(widgets.HBox([button1, button2]))

"""Predictor"""

import warnings

if User_Mode[0] == 'Min_max':
  User_Input = np.array(User_Input).reshape(1,-1)
  User_Input = minmax.transform(User_Input)
  pred_probs = min_max_model.predict(User_Input)
  pred = pred_probs.argmax(axis=1)
  if pred == 0:
    print('Low Wind')
  else:
    warnings.filterwarnings("ignore")
    print('High Wind')

if User_Mode[0] == 'Pwr_Tran':
  User_Input = np.array(User_Input).reshape(1,-1)
  User_Input = power.transform(User_Input)
  pred_probs = pt_model.predict(User_Input)
  pred = pred_probs.argmax(axis=1)
  if pred == 0:
    print('Low Wind')
  elif pred == 1:
    print('High Wind')
  else:
    print('Transient Wind')